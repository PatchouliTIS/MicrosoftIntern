REFERENCE @"Affinity.dll";
REFERENCE @"Affinity.Fusion.dll";
REFERENCE @"Affinity.Scope.dll";
REFERENCE @"Newtonsoft.Json.dll";
REFERENCE @"System.Core.dll";

#DECLARE HeaderPath string = @@HeaderPath@@;
#DECLARE HeaderFile string = Path.GetFileName(@HeaderPath);
#DECLARE NewColName string = "@@NewColName@@";

RESOURCE @HeaderPath;

USING Affinity;
USING Affinity.Scope;

// Outputs
#DECLARE OutputHeader string = @@OutputHeader@@;
#DECLARE OutputExtraction string = @@OutputExtraction@@;

EXTRACT * FROM @@Extraction@@ USING ExtractionLineExtractor(
    headerFile: @HeaderFile,
    columns: "m:QueryId;m:ImpressionGuid;m:Query;m:Url;m:Market;m:DocId;m:Rating;@@ColName@@");

Extraction = SELECT
    ExtractionLine,
    ulong.Parse(m_QueryId) AS ExtractionQueryId,
    m_Url,
    m_ImpressionGuid,
    m_DocId,
    @@ColName@@;

Extraction1 = SELECT
    Extraction.*,
    changeMebRaw(@@ColName@@) AS NewCol
FROM
    Extraction;

SELECT 
    *,
    ExtractionLine AS OldExtractionLine,
    NewCol AS ValueToInsert;
    
NewExtractionLines = PROCESS USING ExtractionLineInsertionProcessor(
    headerFile: @HeaderFile,
    newColumnName: @NewColName);

//
// Output the data
//

SELECT
    ExtractionQueryId,
    NewExtractionLine 
FROM 
    NewExtractionLines
#IF (!@OutputExtraction.Contains("..."))
ORDER BY 
    ExtractionQueryId
#ENDIF
;

OUTPUT TO 
    @OutputExtraction
#IF (@OutputExtraction.Contains("..."))
PARTITIONED BY 
    ExtractionQueryId 
SORTED BY 
    ExtractionQueryId
#ENDIF
USING 
    TsvColumnOutputter("-startColumnIndex", "1");

//
// Output the header
//

SELECT TOP 1 NewHeader FROM NewExtractionLines WHERE RowHasHeader;

SELECT 
    NewHeader, 
    UniversalUtilities.CheckHeaderForCorrectness(NewHeader) AS HeaderIsOk 
HAVING 
    HeaderIsOk;         // The HAVING clause is necessary to inhibit column pruning.
    
SELECT NewHeader;

OUTPUT TO @OutputHeader USING TsvColumnOutputter();


#CS

public static int GetUrlQuickBack(double probQB)
{
    return (int) (probQB * 1000000);
}


public static uint GetMarketAffinityFeature(string marketHierarchyFile, string market, string marketAffinityMap)
{
    var affinity = FeatureComputation.GetMarketAffinityFromL2Metawords(marketHierarchyFile, market, marketAffinityMap);
    var feature = ConvertScoreToFeature(affinity);
    return feature;
}


public static uint? GetMetroAffinityFeature(string metroHierarchyFile, string country, double lat, double lon, string metroAffinityMap)
{
    var locHierarchy = HierarchyComputation.GetMetroHierarchyOrNullOnError(metroHierarchyFile, country, lat, lon);
    if (locHierarchy == null) return null;

    var affinity = FeatureComputation.GetMetroAffinityFromL2Metawords(locHierarchy,  metroAffinityMap);
    var feature = ConvertScoreToFeature(affinity);
    return feature;
}


public static uint ConvertScoreToFeature(double affinity)
{
    if (affinity < -100.0) throw new Exception("Affinity score < -100. Score: " + affinity);
    if (affinity > +100.0) throw new Exception("Affinity score > +100. Score: " + affinity);    

    var quantized = (affinity + 100.0) * 10000.0;
    return (uint) quantized;
}

public static string changeMebRaw(string mebRaw)
{
    if (mebRaw == "")
    {
        return mebRaw;
    }
    double number;
    if (Double.TryParse(mebRaw, out number))
    {
        number = number*1000000;
        return number.ToString();
    }
    else
    {
        return "";
    }
}


public static string JoinStrings(string separator, params string[] parts)
{
    return string.Join(separator, parts);
}
    
#ENDCS

// Generated by ScopeStudio, version 2.3.1000.1
